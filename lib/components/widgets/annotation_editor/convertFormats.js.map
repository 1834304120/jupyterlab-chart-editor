{"version":3,"sources":["../../../../src/components/widgets/annotation_editor/convertFormats.js"],"names":["getTextBlockRegExp","getLaTeXWrappedRegExp","stripHTMLTags","html","replace","trim","extractTextBlocks","matchObj","matchStr","breakTag","matches","stringifiedLaTeX","JSON","stringify","laTeX","regExp","exec","push","join","wrapLaTeX","value","wrapText","isLaTeXExpr","test","hasTextExpression","htmlToLaTeX","trimmedHTML","split","map","para","length","laTeXToHTML","trimmedLaTeX"],"mappings":";;;;;AAAA,IAAMA,qBAAqB,SAArBA,kBAAqB;AAAA,SAAM;AAAN;AAAA,CAA3B;;AAEA;;;;AAIA,IAAMC,wBAAwB,SAAxBA,qBAAwB;AAAA,SAAM;AAAN;AAAA,CAA9B;;AAEA,IAAMC,gBAAgB,SAAhBA,aAAgB;AAAA,SAAQC,KAAKC,OAAL,CAAa,UAAb,EAAyB,EAAzB,EAA6BC,IAA7B,EAAR;AAAA,CAAtB;;AAEA,IAAMC,oBAAoB,SAApBA,iBAAoB,QAAS;AACjC,MAAIC,iBAAJ;AACA,MAAIC,iBAAJ;AACA,MAAMC,WAAW,MAAjB;AACA,MAAMC,UAAU,EAAhB;AACA;AACA,MAAMC,mBAAmBC,KAAKC,SAAL,CAAeC,KAAf,CAAzB;AACA,MAAMC,SAASf,oBAAf;;AAEA;;;;;AAKA,SAAO,CAACO,WAAWQ,OAAOC,IAAP,CAAYL,gBAAZ,CAAZ,MAA+C,IAAtD,EAA4D;AAC1DH,eAAWD,SAAS,CAAT,EAAYF,IAAZ,GAAmBD,OAAnB,CAA2B,KAA3B,EAAkC,EAAlC,CAAX;AACAM,YAAQO,IAAR,CAAaT,QAAb;AACD;;AAED,SAAOE,QAAQQ,IAAR,CAAa,MAAb,CAAP;AACD,CApBD;;AAsBA,IAAMC,YAAY,SAAZA,SAAY;AAAA,SAAUC,cAAYA,KAAZ,SAAuB,IAAjC;AAAA,CAAlB;;AAEA,IAAMC,WAAW,SAAXA,QAAW;AAAA,SAAUD,oBAAkBA,KAAlB,SAA6B,UAAvC;AAAA,CAAjB;;AAEA;AACA;;AAEO,IAAME,oCAAc,SAAdA,WAAc;AAAA,SAASrB,wBAAwBsB,IAAxB,CAA6BH,KAA7B,CAAT;AAAA,CAApB;;AAEA,IAAMI,gDAAoB,SAApBA,iBAAoB,QAAS;AACxC,MAAMT,SAASf,oBAAf;AACA,MAAMW,mBAAmBC,KAAKC,SAAL,CAAeC,KAAf,CAAzB;;AAEA,SAAOC,OAAOQ,IAAP,CAAYZ,gBAAZ,CAAP;AACD,CALM;;AAOA,IAAMc,oCAAc,SAAdA,WAAc,OAAQ;AACjC,MAAMhB,WAAW,MAAjB;AACA,MAAMiB,cAAcvB,KAAKE,IAAL,EAApB;;AAEA;AACA,MAAIqB,gBAAgB,EAApB,EAAwB,OAAOP,UAAUE,UAAV,CAAP;;AAExB;AACA,MAAIK,YAAYtB,OAAZ,CAAoBK,QAApB,EAA8B,EAA9B,MAAsC,EAA1C,EAA8C,OAAOU,UAAUE,UAAV,CAAP;;AAE9C,SAAOF,UACLO,YACGC,KADH,CACSlB,QADT;AAEE;AAFF,GAGGmB,GAHH,CAGO;AAAA,WAASC,KAAKC,MAAL,GAAcT,SAASnB,cAAc2B,IAAd,CAAT,CAAd,GAA8C,EAAvD;AAAA,GAHP,EAIGX,IAJH,CAIQ,IAJR,CADK,CAAP;AAOD,CAjBM;;AAmBA,IAAMa,oCAAc,SAAdA,WAAc,QAAS;AAClC,MAAMC,eAAelB,MAAMT,IAAN,EAArB;;AAEA,SAAOC,kBAAkB0B,YAAlB,CAAP;AACD,CAJM","file":"convertFormats.js","sourcesContent":["const getTextBlockRegExp = () => /\\\\text\\{([^\\}]*)\\}/g;\n\n/**\n * To match any character including newline whitespace, use `[\\s\\S]*`\n * instead of `.*`. http://stackoverflow.com/a/1068308\n */\nconst getLaTeXWrappedRegExp = () => /^\\$[\\s\\S]*\\$$/;\n\nconst stripHTMLTags = html => html.replace(/<[^>]*>/g, \"\").trim();\n\nconst extractTextBlocks = laTeX => {\n  let matchObj;\n  let matchStr;\n  const breakTag = \"<br>\";\n  const matches = [];\n  // Need to stringify to match literally on `\\t`.\n  const stringifiedLaTeX = JSON.stringify(laTeX);\n  const regExp = getTextBlockRegExp();\n\n  /**\n     * Find multiple matches with the ``//g` flag.\n     * The `RegExp.prototype.exec` API mutates the RegExp object.\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec#Finding_successive_matches\n     */\n  while ((matchObj = regExp.exec(stringifiedLaTeX)) !== null) {\n    matchStr = matchObj[1].trim().replace(\"\\\\n\", \"\");\n    matches.push(matchStr);\n  }\n\n  return matches.join(\"<br>\");\n};\n\nconst wrapLaTeX = value => (value ? `$${value}$` : \"$$\");\n\nconst wrapText = value => (value ? `\\\\text{${value}}` : \"\\\\text{}\");\n\n// Exports\n// -------\n\nexport const isLaTeXExpr = value => getLaTeXWrappedRegExp().test(value);\n\nexport const hasTextExpression = laTeX => {\n  const regExp = getTextBlockRegExp();\n  const stringifiedLaTeX = JSON.stringify(laTeX);\n\n  return regExp.test(stringifiedLaTeX);\n};\n\nexport const htmlToLaTeX = html => {\n  const breakTag = \"<br>\";\n  const trimmedHTML = html.trim();\n\n  // Handle empty input\n  if (trimmedHTML === \"\") return wrapLaTeX(wrapText());\n\n  // Handle input with only linebreaks\n  if (trimmedHTML.replace(breakTag, \"\") === \"\") return wrapLaTeX(wrapText());\n\n  return wrapLaTeX(\n    trimmedHTML\n      .split(breakTag)\n      // Ignore empty linebreaks\n      .map(para => (para.length ? wrapText(stripHTMLTags(para)) : \"\"))\n      .join(\"\\n\")\n  );\n};\n\nexport const laTeXToHTML = laTeX => {\n  const trimmedLaTeX = laTeX.trim();\n\n  return extractTextBlocks(trimmedLaTeX);\n};\n"]}