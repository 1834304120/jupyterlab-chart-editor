{"version":3,"sources":["../../../src/components/widgets/NumericInputStatefulWrapper.js"],"names":["customPropTypes","mapPropsToState","propValue","value","defaultValue","mixedMode","NumericInputStatefulWrapper","props","state","onChange","bind","onUpdate","nextProps","setState","integerOnly","max","min","hasDefaultValue","updatedValue","fallbackValue","replace","length","numericBounds","Number","Math","floor","step","showArrows","editableClassName","propTypes","number","string","bool","func","isRequired","customOneOfType","isNumeric","isNull","isDefined","defaultProps"],"mappings":"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","file":"NumericInputStatefulWrapper.js","sourcesContent":["import * as customPropTypes from '@workspace/utils/customPropTypes';\nimport NumericInput from '@workspace/components/widgets/NumericInput';\nimport React, {PropTypes, Component} from 'react';\nimport isNumeric from 'fast-isnumeric';\nimport {MIXED_VALUES, MIXED_MODE_VALUE} from '@workspace/constants/workspace';\nimport {keepWithinMaxMin} from '@workspace/utils/number';\n\n\n/*\n * mapPropsToState, What is this absurdity?!? NumericInputStatefulWrapper\n * maintains state so that users can muck around in the inner NumericInput\n * input box. We don't want to fire updates() each time a user enters a\n * character. Only when the user blurs do we want the update method to be fired.\n * So why map props onto state? The internal state is mapped to the inputbox\n * and with MIXED_VALUE mode we need a way to forcibly change the characters in\n * the inputbox. So incoming props update state but the user is then permitted\n * to make textual changes to the inputbox outside of the knowledge of the\n * Store. Then onBlur we fire onUpdate and the Store can decide whether to keep\n * the value the user inputed or change it to something else. There is also\n * an edge case where we are in mixedMode and showing some special character in\n * the inputbox \"-\" and the user tries to manually edit the input box with\n * garbage and move on. To make it clear that we are still in mixedMode and that\n * no other inputs have been changed we revert their garbage back to \"-\".\n * This requires a setState inside the onUpdate method.\n */\nfunction mapPropsToState({value: propValue, defaultValue = 0}) {\n\n    let value;\n    const mixedMode = propValue === MIXED_VALUES;\n\n    if (mixedMode) {\n\n        /*\n         * MixedMode is useful when indicating to the user that there\n         * is another source of value coming from somewhere else in the\n         * app which renders this control optional. For example a user\n         * may have selected a value for xaxis range and is now exploring\n         * the UI for applying ranges to \"all axes\". In this case a\n         * mixedValue is shown so the user has some visual information that\n         * applying a value to \"all axes\" will somehow supercede some related\n         * value elsewhere. WS2 also provides a more helpful message in these\n         * cases than just the MIXED_MODE_VALUE\n         */\n        value = MIXED_MODE_VALUE;\n\n    } else if (propValue === null) {\n\n        /*\n         * Null is used throughout the App to represent \"no value.\"\n         * This may be an unfortunate decision but NumericInput supports\n         * null by showing the user that the value is actually\n         * \"defaultValue\" or 0.\n         * Actually it would be nice to take this chunk of code out.\n         */\n        value = defaultValue;\n\n    } else {\n        value = propValue;\n    }\n\n    return {value, mixedMode};\n}\n\n\nexport default class NumericInputStatefulWrapper extends Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = mapPropsToState(props);\n\n        this.onChange = this.onChange.bind(this);\n        this.onUpdate = this.onUpdate.bind(this);\n    }\n\n    componentWillReceiveProps(nextProps) {\n        if (nextProps.value !== this.state.value) {\n            this.setState(mapPropsToState(nextProps));\n        }\n    }\n\n    onChange(value) {\n\n        /*\n         * Mixed Mode is preserved until new props are sent down from\n         * upstream components\n         */\n        this.setState({value});\n    }\n\n    onUpdate(value) {\n        const {defaultValue, integerOnly, max, min} = this.props;\n\n        // defaultValue is truthy or numeric (account for falsey 0)\n        const hasDefaultValue = defaultValue || isNumeric(defaultValue);\n        let updatedValue = value;\n\n        /*\n         * If we are in mixed mode and receive the placeholder value then\n         * the user is attempting to increment or decrement. If we are in\n         * mixed mode and receive some other value then the user has entered\n         * this value explicitly in the inputbox and is bluring away.\n         * In the case of incrementing and decrementing we set the updatedValue\n         * to the default value or min or 0. If the value is set explicitly and\n         * is numeric we do the same --- call onUpdate. This allows upstream\n         * components to send in new props that toggle this component out of\n         * mixedValue state. If it is set explicitly in the input box but is not\n         * numeric onUpdate is not called and mixedMode is maintained.\n         * In this case we also force MIXED_MODE_VALUE so the user is aware that\n         * no settings have actually been changed.\n         */\n        if (this.state.mixedMode && updatedValue === MIXED_MODE_VALUE) {\n            const fallbackValue = min || 0;\n            updatedValue = hasDefaultValue ? defaultValue : fallbackValue;\n\n        } else if (this.state.mixedMode && !isNumeric(updatedValue)) {\n\n            /*\n             * mixed mode takes precedence over showing default values when\n             * empty strings are input. We return early to bypass that logic.\n             */\n            this.setState({value: MIXED_MODE_VALUE});\n            return;\n        }\n\n        /*\n         * If supplied a default value use it when the user blurs on an\n         * empty string or string made up of spaces.\n         */\n        if (typeof updatedValue === 'string' && hasDefaultValue) {\n\n            updatedValue = updatedValue.replace(/^\\s+/g, '');\n\n            if (updatedValue.length === 0) {\n                updatedValue = defaultValue;\n            }\n        }\n\n        /*\n         * When correct input is supplied by the user constrain it to be within\n         * [max, min] if max and min are supplied. Ditto for forcing an\n         * integer value. We take the floor instead of rounding\n         * as that is/(may be) less confusing to the user visually.\n         */\n        const numericBounds = isNumeric(min) && isNumeric(max);\n        if (isNumeric(updatedValue)) {\n            updatedValue = Number(updatedValue);\n\n            if (integerOnly) {\n                updatedValue = Math.floor(updatedValue);\n            }\n\n            if (numericBounds) {\n                updatedValue = keepWithinMaxMin(updatedValue, min, max);\n            } else if (isNumeric(min)) {\n                updatedValue = Math.max(min, updatedValue);\n            } else if (isNumeric(max)) {\n                updatedValue = Math.min(max, updatedValue);\n            }\n\n            this.props.onUpdate(updatedValue);\n        }\n    }\n\n    render() {\n        return (\n            <NumericInput\n                value={this.state.value}\n                onUpdate={this.onUpdate}\n                onChange={this.onChange}\n                step={this.props.step}\n                showArrows={this.props.showArrows}\n                editableClassName={this.props.editableClassName}\n            />\n        );\n    }\n}\n\nNumericInputStatefulWrapper.propTypes = {\n\n    /*\n     * defaultValue is default value used when\n     * A) a user leaves the input empty or filled with spaces.\n     * B) a user is moving out of mixed mode.\n     * C) a `null` value is supplied to this component.\n     */\n    defaultValue: PropTypes.number,\n    editableClassName: PropTypes.string,\n\n    /*\n     * When integerOnly flag is set any numeric input supplied by\n     * the user is constrained to be a whole integer number.\n     * Math.floor is used for this operation.\n     */\n    integerOnly: PropTypes.bool,\n\n    /*\n     * If min is supplied and defaultValue is *not* supplied the min\n     * value will be used when the user moves out of mixed mode.\n     * If both min and max are supplied they are used to constrain\n     * numeric input from the user to be within this range.\n     */\n    max: PropTypes.number,\n    min: PropTypes.number,\n\n    /*\n     * Handler run onBlur and called with the updated value.\n     */\n    onUpdate: PropTypes.func.isRequired,\n\n    /*\n     * showArrows is a flag that will show or hide the increment and\n     * decrement buttons on the side of the inputbox. Defaults to true.\n     */\n    showArrows: PropTypes.bool,\n\n    /*\n     * If incrementors are present step size controls the numeric step taken\n     * when incrementing and decrementing.\n     */\n    step: PropTypes.number,\n\n    value: customPropTypes.customOneOfType([\n        PropTypes.string,\n        customPropTypes.isNumeric,\n        customPropTypes.isNull\n    ]).isDefined\n};\n\nNumericInputStatefulWrapper.defaultProps = {\n    showArrows: true\n};\n"]}