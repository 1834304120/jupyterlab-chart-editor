{"version":3,"sources":["../../../src/components/widgets/NumericInputStatefulWrapper.js"],"names":["mapPropsToState","propValue","value","defaultValue","mixedMode","NumericInputStatefulWrapper","props","state","onChange","bind","onUpdate","nextProps","setState","integerOnly","max","min","hasDefaultValue","updatedValue","fallbackValue","replace","length","numericBounds","Number","Math","floor","step","showArrows","editableClassName","propTypes","number","string","bool","func","isRequired","any","defaultProps"],"mappings":"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","file":"NumericInputStatefulWrapper.js","sourcesContent":["import NumericInput from \"./NumericInput\";\nimport React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport isNumeric from \"fast-isnumeric\";\nimport { MIXED_VALUES, MIXED_MODE_VALUE } from \"../workspace-constants\";\nimport { clamp } from \"../../common\";\n\n// mapPropsToState, What is this absurdity?!? NumericInputStatefulWrapper\n// maintains state so that users can muck around in the inner NumericInput\n// input box. We don't want to fire updates() each time a user enters a\n// character. Only when the user blurs do we want the update method to be fired.\n// So why map props onto state? The internal state is mapped to the inputbox\n// and with MIXED_VALUE mode we need a way to forcibly change the characters in\n// the inputbox. So incoming props update state but the user is then permitted\n// to make textual changes to the inputbox outside of the knowledge of the\n// Store. Then onBlur we fire onUpdate and the Store can decide whether to keep\n// the value the user inputed or change it to something else. There is also\n// an edge case where we are in mixedMode and showing some special character in\n// the inputbox \"-\" and the user tries to manually edit the input box with\n// garbage and move on. To make it clear that we are still in mixedMode and that\n// no other inputs have been changed we revert their garbage back to \"-\".\n// This requires a setState inside the onUpdate method.\nfunction mapPropsToState({ value: propValue, defaultValue = 0 }) {\n  let value;\n  const mixedMode = propValue === MIXED_VALUES;\n\n  if (mixedMode) {\n    // MixedMode is useful when indicating to the user that there\n    // is another source of value coming from somewhere else in the\n    // app which renders this control optional. For example a user\n    // may have selected a value for xaxis range and is now exploring\n    // the UI for applying ranges to \"all axes\". In this case a\n    // mixedValue is shown so the user has some visual information that\n    // applying a value to \"all axes\" will somehow supercede some related\n    // value elsewhere. WS2 also provides a more helpful message in these\n    // cases than just the MIXED_MODE_VALUE\n    value = MIXED_MODE_VALUE;\n  } else if (propValue === null) {\n    // Null is used throughout the App to represent \"no value.\"\n    // This may be an unfortunate decision but NumericInput supports\n    // null by showing the user that the value is actually\n    // \"defaultValue\" or 0.\n    // Actually it would be nice to take this chunk of code out.\n    value = defaultValue;\n  } else {\n    value = propValue;\n  }\n\n  return { value, mixedMode };\n}\n\nexport default class NumericInputStatefulWrapper extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = mapPropsToState(props);\n\n    this.onChange = this.onChange.bind(this);\n    this.onUpdate = this.onUpdate.bind(this);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.value !== this.state.value) {\n      this.setState(mapPropsToState(nextProps));\n    }\n  }\n\n  onChange(value) {\n    /*\n         * Mixed Mode is preserved until new props are sent down from\n         * upstream components\n         */\n    this.setState({ value });\n  }\n\n  onUpdate(value) {\n    const { defaultValue, integerOnly, max, min } = this.props;\n\n    // defaultValue is truthy or numeric (account for falsey 0)\n    const hasDefaultValue = defaultValue || isNumeric(defaultValue);\n    let updatedValue = value;\n\n    // If we are in mixed mode and receive the placeholder value then\n    // the user is attempting to increment or decrement. If we are in\n    // mixed mode and receive some other value then the user has entered\n    // this value explicitly in the inputbox and is bluring away.\n    // In the case of incrementing and decrementing we set the updatedValue\n    // to the default value or min or 0. If the value is set explicitly and\n    // is numeric we do the same --- call onUpdate. This allows upstream\n    // components to send in new props that toggle this component out of\n    // mixedValue state. If it is set explicitly in the input box but is not\n    // numeric onUpdate is not called and mixedMode is maintained.\n    // In this case we also force MIXED_MODE_VALUE so the user is aware that\n    // no settings have actually been changed.\n    if (this.state.mixedMode && updatedValue === MIXED_MODE_VALUE) {\n      const fallbackValue = min || 0;\n      updatedValue = hasDefaultValue ? defaultValue : fallbackValue;\n    } else if (this.state.mixedMode && !isNumeric(updatedValue)) {\n      // mixed mode takes precedence over showing default values when\n      // empty strings are input. We return early to bypass that logic.\n      this.setState({ value: MIXED_MODE_VALUE });\n      return;\n    }\n    // If supplied a default value use it when the user blurs on an\n    // empty string or string made up of spaces.\n    if (typeof updatedValue === \"string\" && hasDefaultValue) {\n      updatedValue = updatedValue.replace(/^\\s+/g, \"\");\n\n      if (updatedValue.length === 0) {\n        updatedValue = defaultValue;\n      }\n    }\n\n    // When correct input is supplied by the user constrain it to be within\n    // [max, min] if max and min are supplied. Ditto for forcing an\n    // integer value. We take the floor instead of rounding\n    // as that is/(may be) less confusing to the user visually.\n    const numericBounds = isNumeric(min) && isNumeric(max);\n    if (isNumeric(updatedValue)) {\n      updatedValue = Number(updatedValue);\n\n      if (integerOnly) {\n        updatedValue = Math.floor(updatedValue);\n      }\n\n      if (numericBounds) {\n        updatedValue = clamp(updatedValue, min, max);\n      } else if (isNumeric(min)) {\n        updatedValue = Math.max(min, updatedValue);\n      } else if (isNumeric(max)) {\n        updatedValue = Math.min(max, updatedValue);\n      }\n\n      this.props.onUpdate(updatedValue);\n    }\n  }\n\n  render() {\n    return (\n      <NumericInput\n        value={this.state.value}\n        onUpdate={this.onUpdate}\n        onChange={this.onChange}\n        step={this.props.step}\n        showArrows={this.props.showArrows}\n        editableClassName={this.props.editableClassName}\n      />\n    );\n  }\n}\n\nNumericInputStatefulWrapper.propTypes = {\n  // defaultValue is default value used when\n  // A) a user leaves the input empty or filled with spaces.\n  // B) a user is moving out of mixed mode.\n  // C) a `null` value is supplied to this component.\n  defaultValue: PropTypes.number,\n  editableClassName: PropTypes.string,\n\n  // When integerOnly flag is set any numeric input supplied by\n  // the user is constrained to be a whole integer number.\n  // Math.floor is used for this operation.\n  integerOnly: PropTypes.bool,\n\n  // If min is supplied and defaultValue is *not* supplied the min\n  // value will be used when the user moves out of mixed mode.\n  // If both min and max are supplied they are used to constrain\n  // numeric input from the user to be within this range.\n  max: PropTypes.number,\n  min: PropTypes.number,\n\n  // Handler run onBlur and called with the updated value.\n  onUpdate: PropTypes.func.isRequired,\n\n  // showArrows is a flag that will show or hide the increment and\n  // decrement buttons on the side of the inputbox. Defaults to true.\n  showArrows: PropTypes.bool,\n\n  // If incrementors are present step size controls the numeric step taken\n  // when incrementing and decrementing.\n  step: PropTypes.number,\n\n  value: PropTypes.any,\n  /*value: customPropTypes.customOneOfType([\n    PropTypes.string,\n    customPropTypes.isNumeric,\n    customPropTypes.isNull,\n  ]).isDefined,*/\n};\n\nNumericInputStatefulWrapper.defaultProps = {\n  showArrows: true,\n};\n"]}