{"version":3,"sources":["../../../src/components/widgets/FlaglistCheckboxGroup.js"],"names":["FlaglistCheckboxGroup","createClass","propTypes","options","PropTypes","arrayOf","shape","value","string","isRequired","label","activeOption","onChange","func","className","orientation","_parseFlags","option","props","map","o","join","getInitialState","currentActiveOption","componentWillReceiveProps","nextProps","setState","handleChange","newOptions","newActiveOptions","checked","slice","length","renderCheckedOption","activeOptions","state","split","allOptions","currentChecked","indexOf","push","render","module","exports"],"mappings":"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","file":"FlaglistCheckboxGroup.js","sourcesContent":["import React from \"react\";\nimport CheckboxGroup from \"./CheckboxGroup\";\n\n// Component handles activeOption with shape \"x+y+z\"\n// and ties it to the CheckboxGroup Component\nconst FlaglistCheckboxGroup = React.createClass({\n  propTypes: {\n    options: React.PropTypes.arrayOf(\n      React.PropTypes.shape({\n        value: React.PropTypes.string.isRequired,\n        label: React.PropTypes.string.isRequired,\n      })\n    ).isRequired,\n    activeOption: React.PropTypes.string,\n    onChange: React.PropTypes.func,\n    className: React.PropTypes.string,\n    orientation: React.PropTypes.string,\n  },\n\n\n  // convert plotly.js's \"all\" or \"none\" option in its `flaglist` type\n  // to a series of options separated by `+` that our component can handle\n  _parseFlags(option) {\n    let activeOption;\n    if (option === \"all\") {\n      activeOption = this.props.options.map(o => o.value).join(\"+\");\n    } else if (option === \"none\") {\n      activeOption = \"\";\n    } else {\n      activeOption = option;\n    }\n    return activeOption;\n  },\n\n  getInitialState() {\n    let currentActiveOption;\n    if (this.props.activeOption !== null) {\n      currentActiveOption = this.props.activeOption;\n    } else {\n      currentActiveOption = \"\";\n    }\n\n    return {\n      activeOption: this._parseFlags(currentActiveOption),\n    };\n  },\n\n\n  // Sync local state to parent props.\n  componentWillReceiveProps(nextProps) {\n    this.setState({ activeOption: this._parseFlags(nextProps.activeOption) });\n  },\n\n\n  // Called whenever a checkbox is changed, this updates the local\n  // state to reflect the new activeOptions and then called props.onChange with\n  // the new options.\n  handleChange(newOptions) {\n    let newActiveOptions = \"\";\n\n    newOptions.map(option => {\n      if (option.checked === true) {\n        newActiveOptions += option.value + \"+\";\n      }\n    });\n\n    newActiveOptions = newActiveOptions.slice(0, -1);\n\n    if (newActiveOptions.length === 0) {\n      newActiveOptions = \"none\";\n    }\n\n    this.setState({ activeOption: newActiveOptions });\n    this.props.onChange(newActiveOptions);\n  },\n\n  // Turns the activeOptions \"e.g \"x+y+z\" into an array that\n  // the CheckboxGroup component can handle\n  renderCheckedOption() {\n    const activeOptions = this.state.activeOption.split(\"+\");\n    const allOptions = this.props.options;\n    let newOptions = [];\n\n    allOptions.map(option => {\n      let currentChecked;\n\n      if (activeOptions.indexOf(option.value) > -1) {\n        currentChecked = true;\n      } else {\n        currentChecked = false;\n      }\n\n      newOptions.push({\n        label: option.label,\n        value: option.value,\n        checked: currentChecked,\n      });\n    });\n\n    return newOptions;\n  },\n\n  render() {\n    return (\n      <CheckboxGroup\n        options={this.renderCheckedOption()}\n        onChange={this.handleChange}\n        className={this.props.className}\n        orientation={this.props.orientation}\n      />\n    );\n  },\n});\n\nmodule.exports = FlaglistCheckboxGroup;\n"]}